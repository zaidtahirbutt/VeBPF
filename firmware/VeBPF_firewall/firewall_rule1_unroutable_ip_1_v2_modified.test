-- asm
# Get Ethertype from received packet
mov32 r1, 12
ldxh r4, [r1]
be16 r4

# Check if IP4
jeq r4, 0x0800, +2
# if pkt is not IP4 then save result as dont care and exit this prog
mov r0, 0x01  
exit

# not looking at ipv4 IHL since normally it is 5

# read src ipaddr
# 14 bytes of eth hdr + 12 bytes of ip hdr = 26 bytes till src ipaddr
# need to read 4 bytes of src ipaddr
mov32 r1, 26
ldxw r4, [r1]
be32 r4

# check if src ipaddr is eq to 245:255:255:255 = 0xF5 0xFF 0xFF 0xFF saved as L.E in data mem
# mac address of 0x04 0x00 0x00 0x00 0x00 0x00 when read using ldxdw r2 was loaded as 0x00 0x00 0x00 0x00 0x00 0x04
# since eBPF is a L.E system since its LINUX based, thats why we have to do be16 above to make it big endian for
# more human readable comps
jeq r4, 0xF5FFFFFF, +2

# if pkt src ipaddr is not 245:255:255:255 save result as dont care and exit this prog
mov r0, 0x01
# move r0, 0x01  
	# HAD TO DO A LOT OF DEBUGGING CX OF THIS MOVEEEEE INST!! its MOV not MOVE!
exit

# if pkt src ipaddr is 245:255:255:255 save result 0x02 in r0  (means firewall rule1 got activated) and exit this prog
mov r0, 0x02  
exit

-- result
0x0000000000000002
# This test outputs 0x1 if the SRC IPADDR of rxpkt is 245:255:255:255
# localparam VEBPF_RESULT_ERROR = 253;
# localparam VEBPF_RESULT_DROP_PKT = 254;
# localparam VEBPF_RESULT_DONT_CARE_KEEP_PROCESSING = 1;
